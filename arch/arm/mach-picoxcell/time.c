/*
 * Copyright (c) 2010 Picochip Ltd., Jamie Iles
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * All enquiries to support@picochip.com
 */
#include <linux/clockchips.h>
#include <linux/clocksource.h>
#include <linux/cnt32_to_63.h>
#include <linux/interrupt.h>
#include <linux/irq.h>
#include <linux/platform_device.h>
#include <linux/sched.h>

#include <asm/mach/time.h>
#include <asm/sched_clock.h>

#include <mach/hardware.h>

#include "picoxcell_core.h"
#include "soc.h"

static struct resource timer0_res[] = {
	{
		.start	= PICOXCELL_TIMER_BASE,
		.end	= PICOXCELL_TIMER_BASE + TIMER_SPACING - 1,
		.flags	= IORESOURCE_MEM,
	},
	{
		.start	= IRQ_TIMER0,
		.end	= IRQ_TIMER0,
		.flags	= IORESOURCE_IRQ,
	},
};

static struct resource timer1_res[] = {
	{
		.start	= PICOXCELL_TIMER_BASE + TIMER_SPACING,
		.end	= PICOXCELL_TIMER_BASE + 2 * TIMER_SPACING - 1,
		.flags	= IORESOURCE_MEM,
	},
};

static struct platform_device timer0 = {
	.name		= "dw_apb_timer",
	.id		= 0,
	.resource	= timer0_res,
	.num_resources	= ARRAY_SIZE(timer0_res),
};

static struct platform_device timer1 = {
	.name		= "dw_apb_timer",
	.id		= 1,
	.resource	= timer1_res,
	.num_resources	= ARRAY_SIZE(timer1_res),
};

static struct platform_device *picoxcell_early_devices[] __initdata = {
	&timer0,
	&timer1,
};

static void __init picoxcell_timer_init(void)
{
	early_platform_add_devices(picoxcell_early_devices,
				   ARRAY_SIZE(picoxcell_early_devices));
	early_platform_driver_register_all("earlytimer");
	early_platform_driver_probe("earlytimer", 2, 0);
}

struct sys_timer picoxcell_sys_timer = {
	.init	= picoxcell_timer_init,
};

/*
 * picoxcell's sched_clock implementation. It has a resolution of 5ns
 * (200MHz).
 */
static DEFINE_CLOCK_DATA(cd);

/*
 * Constants generated by:
 *	clocks_calc_mult_shift(m, s, 200000000, NSEC_PER_SEC, 0);
 */
#define SC_MULT		2684354560LU
#define SC_SHIFT	29

unsigned long long notrace sched_clock(void)
{
	u32 cyc = __raw_readl(IO_ADDRESS(PICOXCELL_RTCLK_BASE) +
			      RTCLK_CCV_REG_OFFSET);
	return cyc_to_fixed_sched_clock(&cd, cyc, (u32)~0, SC_MULT, SC_SHIFT);
}

static void notrace picoxcell_update_sched_clock(void)
{
	u32 cyc = __raw_readl(IO_ADDRESS(PICOXCELL_RTCLK_BASE) +
			      RTCLK_CCV_REG_OFFSET);
	update_sched_clock(&cd, cyc, (u32)~0);
}

void __init picoxcell_sched_clock_init(void)
{
	/*
	 * Reset the RTC. We don't know how long the RTC has been running for
	 * in the bootloader.
	 */
	__raw_writel(0, IO_ADDRESS(PICOXCELL_RTCLK_BASE +
				   RTCLK_SET_REG_OFFSET));
	init_fixed_sched_clock(&cd, picoxcell_update_sched_clock, 32,
			       CLOCK_TICK_RATE, SC_MULT, SC_SHIFT);
}
